# TSSr: an R/Bioconductor package for comprehensive analyses of transcription start sit (TSS) data

##### Zhaolian Lu, Keenan Berry, Zhenbin Hu, Yu Zhan, Tae-Hyuk Ahn, Zhenguo Lin


## 1. Intruduction

Documentation is also available on GitHub Pages: https://github.com/Linlab-slu/TSSr

 TSSr is an R package that provides rich functions for mapping transcription start sites (TSSs) and characterizations of structures and activities of core promoters based on all types of TSS sequencing data, such as cap analysis of gene expression (CAGE) (Takahashi, Lassmann et al. 2012), no-amplification non-tagging CAGE libraries for Illumina next-generation sequencers (nAnT-iCAGE) (Murata, Nishiyori-Sueki et al. 2014), a Super-Low Input Carrier-CAGE (SLIC-CAGE) (Cvetesic, Leitch et al. 2018), NanoCAGE (Cumbie, Ivanchenko et al. 2015), TSS-seq (Malabat, Feuerbach et al. 2015), transcript isoform sequencing (TIF-seq) (Pelechano, Wei et al. 2013), transcript-leaders sequencing (TL-seq) (Arribere and Gilbert 2013), precision nuclear run-on sequencing (PRO-Cap) (Mahat, Kwak et al. 2016), and GRO-Cap/5’GRO-seq (Kruesi, Core et al. 2013).
 
 TSSr package provides a comprehensive workflow on TSS data starts from accurate identification of TSS locations, clustering TSSs within small genomic regions to infer core promoters, and quantifications of transcriptional activity, as well as specialized downstream analyses including quantification of core promoter shape, asigning TSS cluster to genes, gene differential expression, core promoter shift. TSSr can take multiple formats of files as input, such as Binary Sequence Alignment Mao (BAM) files (single-ended or paired-ended), Browser Extension Data (bed) files, BigWig files, ctss files or tss tables. TSSr generates various types of TSS or core promoter track files which can be visualized in the UCSC Genome Browser or Integrative Genomics Viewer (IGV). TSSr also exports various raw and processed result tables and visualization plots. Multiple cores are supported on Linux or Mac platforms.
 
## 2. Pre-requisites:

* R version
  * Download R (>3.4.0) version from CRAN.
    * Windows: https://cran.r-project.org/bin/windows/base/
    * Mac OS X: https://cran.r-project.org/bin/macosx/
    * Linux: https://cran.r-project.org/bin/linux/

- Rsamtools package

  * install by using the following R commands:

        if (!requireNamespace("BiocManager", quietly = TRUE))
        install.packages("BiocManager")
        BiocManager::install("Rsamtools")


- GenomicRanges

  * install by using the following R commands:

        if (!requireNamespace("BiocManager", quietly = TRUE))
        install.packages("BiocManager")
        BiocManager::install("GenomicRanges")

- GenomicFeature package

  * install by using the following R commands:

        if (!requireNamespace("BiocManager", quietly = TRUE))
        install.packages("BiocManager")
        BiocManager::install("GenomicFeatures")

- Gviz package

  * install by using the following R commands:

        if (!requireNamespace("BiocManager", quietly = TRUE))
        install.packages("BiocManager")
        BiocManager::install("Gviz")  

- rtracklayer package

  * install by using the following R commands:

        if (!requireNamespace("BiocManager", quietly = TRUE))
        install.packages("BiocManager")
        BiocManager::install("rtracklayer")

- DESeq2 package:

  * install by using the following R command:

        if (!requireNamespace("BiocManager", quietly = TRUE))
        install.packages("BiocManager")
        BiocManager::install("DESeq2")

- BSgenome package

  * install by using the following R command:

        if (!requireNamespace("BiocManager", quietly = TRUE))
        install.packages("BiocManager")
        BiocManager::install("BSgenome")

- data.table package

  * install by using the following R command:

        if (!requireNamespace("data.table", quietly = TRUE))
        install.packages("data.table")

- stringr package

  * install by using the following R command:

        if (!requireNamespace("stringr", quietly = TRUE))
        install.packages("stringr")
	

## 3. Installing TSSr Package:

To install the TSSr package all the prerequisites above need to be installed.
After confirming those packages are installed, you can install the development version directly from GitHub using devtools:

        devtools::install_github("Linlab-slu/TSSr")

## 4. Input data for TSSr

* Input data files

  TSSr accepts two types of input data: read alignment files or TSS tables. 
  The read alignment files in compressed binary alignment map (BAM) format are required if users intend to call TSSs from mapped sequencing data. BAM files can be derived from mapping of either paired-end or single-end TSS sequencing reads. 
  TSSr also accepts TSS tables generated by TSSr or other bioinformatics tools as input data. A TSS table can be a tab-delimited text file, a BigWig (bw) binary type file, or browser extensible data (bed) type file. A tab-delimited TSS table contains chromosome ID, genomic coordinates, strand information, and raw or normalized read counts of each sample. An example of TSS table can be downlaoded from http://zlinlab.org/TSSr/ALL.samples.TSS.raw.txt. 
  

* Reference genome

  The reference genome stored as a BSgenome data package must be provided to determine the presence of genome uncoded G cap in sequencing read during TSS calling. For available BSgenome genome objects, please check (https://bioconductor.org/packages/BSgenome). In case the BSgenome object is unavailable for a species in BSgenome package (not in the list returned by BSgenome::available.genomes() function), a custom genome has to be built and installed before run through this package. (See the vignette “How to forge a BSgenome data package” within the BSgenome package for instructions). A genome annotation file (GTF or GFF file) is required to assign TSS clusters to genes or genomic features by using the annotateCluster function. The chromosome names in BSgenome, genome annotation file as well as the reference genome used for mapping sequencing reads must be matched.  

* S4 object

  TSSr uses S4 object to store all input files and arguments and generate downstream analysis results.

## 5. Usage:

* Launch TSSr

        library(TSSr)
      
* Users may explore the fucntions of TSSr using provided example TSSr object "exampleTSSr". Skip this step if the user plan to generate a new TSSr object from bam or TSS table files 

        myTSSr <- exampleTSSr 
        
* Generating a new TSSr object from BAM or TSS table files. The first step is to provide the path and file names of input files "inputFiles". Four example BAM files (S01.sorted.bam, S02.sorted.bam, S03.sorted.bam, S04.sorted.bam) can be downloaded from http://www.zlinlab.org/TSSr.html. These BAM files were obtained from a budding yeast Saccharomyces cerevisiae based on CAGE sequencing (Lu and Lin 2019). The CAGE reads were mapped to the reference genome of S. cerevisiae (R64-2-1) using HISAT2 (Kim, Langmead et al. 2015). To reduced sample file size, each BAM file only includes sequencing reads mapped to two chromosomes (Chr I and Chr II). A TSS table genereated from the four BAM files can be downloaded from http://zlinlab.org/TSSr/ALL.samples.TSS.raw.txt. 

        inputFiles <- c("S01.sorted.bam", "S02.sorted.bam", "S03.sorted.bam", "S04.sorted.bam") # if use a TSS table: inputFiles <- "ALL.samples.TSS.raw.txt"
        inputFilesType <- "bam" # set “inputFilesType” as “bamPairedEnd” for paired-end BAM files, and as "TSStable" if input data is a TSS table 
	
* Install required BSgenome object. The example CAGE data was obtained from Saccharomyces cerevisiae. The BSgenome object for S. cerevisiae “BSgenome.Scerevisiae.UCSC.sacCer3” is available from BSgenome Bioconductor package (https://bioconductor.org/packages/BSgenome). 

        if (!requireNamespace("BSgenome.Scerevisiae.UCSC.sacCer3", quietly = TRUE))
        BiocManager::install("BSgenome.Scerevisiae.UCSC.sacCer3")
        library(BSgenome.Scerevisiae.UCSC.sacCer3) 
	
* Provide path and file name of genome annotation file. The example genome annotation of S. cerevisiae (R64-2-1) was originally obtained from the Saccharomyces Genome Database. It ban be downlaoded from http://zlinlab.org/TSSr/saccharomyces_cerevisiae_R64-2-1.gff .

        refSource <- "saccharomyces_cerevisiae_R64-2-1.gff" 
	
* Creating a new TSSr object using the constructer "new" function. In addition to the input data file "inputFiles" and file type "inputFilesType", BSgenome object name, and genome annotaion file "refSource", this step also requires users to provide more information about the samples, including "sampleLabels", "sampleLabelsMerged", and "mergeIndex" and "organismName". In the example data, sample lables "SL01, SL02, SL03 and SL04" were used for "S01.sorted.bam, S02.sorted.bam, S03.sorted.bam, S04.sorted.bam", respectively (sampleLabels = c("SL01","SL02","SL03","SL04")). If a TSS table is used as input data, the sample lable of each sample is its column name in the TSS table. "sampleLabelsMerged" will be used if the user need to merge TSS signals from multiple samples (e.g., biological replicates) into a single dataset. In this case, SL01 and SL02 are two biological replicates obtained from S. cerevisiae cells grown in rich medium ("control"), while SL03 and SL04 were obtained by treating S. cerevisiae with α factor ("treat"). Thus, sampleLabelsMerged = c("control","treat") and mergeIndex = c(1,1,2,2), which means SL01 and SL02 will be merged as group 1 "control", and SL03 and SL04 will be merged as group 2 "treat". "organismName" is the species name of the samples, which will be used to annotate TSS clusters by "annotateCluster".

        myTSSr <- new("TSSr", genomeName = "BSgenome.Scerevisiae.UCSC.sacCer3"
	              ,inputFiles = inputFiles
	              ,inputFilesType = inputFilesType
	              ,sampleLabels = c("SL01","SL02","SL03","SL04")
	              ,sampleLabelsMerged = c("control","treat")
	              ,mergeIndex = c(1,1,2,2)
	              ,refSource = refSource
	              ,organismName = "saccharomyces cerevisiae")
	
	To display the available slots in the created TSSr object by typing the TSSr object name. Most slots in the newly created TSSr object are empty at this point since no analysis has been conducted.:
	
	     myTSSr
	      
        # An object of class "TSSr"
        # Slot "genomeName":
        # [1] "BSgenome.Scerevisiae.UCSC.sacCer3"
        # 
        # Slot "inputFiles":
        # [1] "S01.sorted.bam" "S02.sorted.bam" "S03.sorted.bam" "S04.sorted.bam"
        # 
        # Slot "inputFilesType":
        # [1] "bam"
        # 
        # Slot "sampleLabels":
        # [1] "SL01" "SL02" "SL03" "SL04"
        # 
        # Slot "sampleLabelsMerged":
        # [1] "control" "treat"  
        # 
        # Slot "librarySizes":
        # numeric(0)
        # 
        # Slot "TSSrawMatrix":
        # data frame with 0 columns and 0 rows
        # 
        # Slot "mergeIndex":
        # [1] 1 1 2 2
        # 
        # Slot "TSSprocessedMatrix":
        # data frame with 0 columns and 0 rows
        # 
        # Slot "tagClusters":
        # list()
        # 
        # Slot "consensusClusters":
        # list()
        # 
        # Slot "clusterShape":
        # list()
        # 
        # Slot "refSource":
        # [1] "saccharomyces_cerevisiae_R64-2-1.gff"
        # 
        # Slot "refTable":
        # data frame with 0 columns and 0 rows
        # 
        # Slot "organismName":
        # [1] "Saccharomyces cerevisiae"
        # 
        # Slot "assignedClusters":
        # list()
        # 
        # Slot "unassignedClusters":
        # list()
        # 
        # Slot "filteredClusters":
        # list()
        # 
        # Slot "DEtables":
        # list()
        # 
        # Slot "TAGtables":
        # list()
        # 
        # Slot "PromoterShift":
        # list()
	
		
* TSS calling from bam files or retrieving TSS data from TSS table using "getTSS" function. The "getTSS" function identifies genomic coordinates of all TSSs and read counts supporting each TSS from each sample and return values to one data table. Before TSS calling, TSSr removes reads that are below certain sequencing quality and mapping quality. The default threshold for Phred quality score is 10, and mapping quality (MAPQ score) is 20. Users may change these parameters by setting different values for “sequencingQualityThreshold” and “mappingQualityThreshold” when running the “getTSS” function. If a mapped TSS sequencing read starts with a G that is a mismatch to the reference genome, the uncoded 5’ end G is likely the m7G cap, and thus it will be removed from TSS calling by "getTSS". If a matched G at the 5’end of a tag is considered as an added cap, TSSr treats the 5’end of reads with matched G as genome-coded G, and the first G is not removed when calling TSS positions. This strategy is based on a stronge preference of PyPu dinucleotide at the [-1, +1] sites. This strategy makes TSSr also suitable for calling TSSs from 5’end sequencing reads that are not based on cap capture techniques.  
	
        getTSS(myTSSr)
	
	TSS calling from bam files or retrieving TSS data from TSS table         
        myTSSr@TSSrawMatrix
        
        #           chr    pos strand SL01 SL02 SL03 SL04
        #      1:  chrI   1561      +    0    0    0    1
        #      2:  chrI   5759      +    1    0    0    0
        #      3:  chrI   5765      +    1    0    0    0
        #      4:  chrI   5773      +    1    0    0    0
        #      5:  chrI   5925      +    0    1    0    0
        #     ---                                        
        # 163208: chrII 810860      -    0    0    0    2
        # 163209: chrII 810963      -    0    1    0    0
        # 163210: chrII 811112      -    0    0    1    0
        # 163211: chrII 811370      -    1    0    0    0
        # 163212: chrII 812101      -    1    0    0    0

* TSSrawMatrix contains genomic coordinates and read counts of each called TSS. TSSrawMatrix can be exported by "exportTSStable" function to a TSS table "ALL.samples.TSS.raw.txt" in the working directory. The TSS table can be used as input file for future downstram analyses using TSSr or other tools. It is advised to export unmerged TSSrawMatrix to an TSS table to avoid repeated TSS calling step.    

        exportTSStable(myTSSr, data = "raw", merged = "FALSE")
	
* The "plotCorrelation" function is used to calculate the pairwise correlation coefficients and plot pairwise scatter plots of TSS counts. A subset of samples can also be specified to display the pairwise correlations. Three correlation methods are supported: “pearson”, “kendall”, or “spearman”. The default setting generates scatter plots for all samples (samples = "all"). For plotting a subset of samples, users may provide a list of sample labels for "sample", e.g., samples = c("SL01","SL02","SL03"). 
	
        plotCorrelation(myTSSr, samples = "all")
        
![01_TSS_correlation_plot_of_all_samples](https://github.com/Linlab-slu/TSSr/raw/master/vignettes/figures/01_TSS_correlation_plot_of_all_samples_v2.png)

 * TSS includes "plotPCA" function to plot results principle component analysis (PCA) of all samples to obtain an overview of the TSS data in a low-dimensional subspace and for quality assessment. plotPCA will make a biplot which visualizes both how samples relate to each other in terms of the first principal component (PC1) and the second principal component (PC2) and simultaneously show how each variable contributes to each principal component.
  
        plotTssPCA(myTSSr, TSS.threshold=10)

![02_PCA_plot](https://github.com/Linlab-slu/TSSr/raw/master/vignettes/figures/02_PCA_plot_v2.png)

* Merging samples (biological replicates). Users can merge multiple samples (e.g., biological replicates) into previously defined groups with mergeSamples function. The "mergeIndex" argument directs which samples will be merged and how the final dataset will be ordered accordingly. The merged read counts and genomic coordinates are stored in the TSSprocessedMatrix slot.
  
        mergeSamples(myTSSr)
        
        myTSSr@TSSprocessedMatrix
        
        #           chr    pos strand control treat
        #      1:  chrI   1561      +       0     1
        #      2:  chrI   5759      +       1     0
        #      3:  chrI   5765      +       1     0
        #      4:  chrI   5773      +       1     0
        #      5:  chrI   5925      +       1     0
        #     ---                                  
        # 163208: chrII 810860      -       0     2
        # 163209: chrII 810963      -       1     0
        # 163210: chrII 811112      -       0     1
        # 163211: chrII 811370      -       1     0
        # 163212: chrII 812101      -       1     0

  To return library sizes (number of total read counts) of merged samples in TSSr object in the specified order (note: order is specified in mergeSample function):

        myTSSr@librarySizes
        # control   treat 
        # 3221609 5131202

  Library sizes among different samples are different. To provide between-sample comparability, the raw read counts of each TSS need to be scaled as tags per million mapped reads (TPM) with normalizeTSS function.

        normalizeTSS(myTSSr)
        
  Users may use the “filterTSS” option to remove TSSs with low support from mapped reads based on TMP value or p-value inferred by “Poisson distribution”. For "TPM" filtering (method = "TPM"), any TSS that has a lower TPM value than user-defined threshold "tpmLow" will be removed (default TPM threshold = 0.1). For "poisson" method (method = "poisson"), TSSr calculates the probability of observing k numbers of reads supporting each TSS based on the sequencing depth of the sample per the Poisson distribution. Only TSSs with a significantly larger number of supporting reads than expected (default threshold p < 0.01) are considered as qualified TSSs. Non-significant TSSs are thus filtered by TSSr. 

        filterTSS(myTSSr, method = "poisson")   
    
        myTSSr@TSSprocessedMatrix
        
        #           chr    pos strand  control    treat
        #      1:  chrI   1561      + 0.000000 0.194886
        #      2:  chrI   5759      + 0.310404 0.000000
        #      3:  chrI   5765      + 0.310404 0.000000
        #      4:  chrI   5773      + 0.310404 0.000000
        #      5:  chrI   5925      + 0.310404 0.000000
        #     ---                                      
        # 163208: chrII 810860      - 0.000000 0.389772
        # 163209: chrII 810963      - 0.310404 0.000000
        # 163210: chrII 811112      - 0.000000 0.194886
        # 163211: chrII 811370      - 0.310404 0.000000
        # 163212: chrII 812101      - 0.310404 0.000000

  Simialr to the raw read counts, the normalized and filtered (processed) TSS matrix can be exported to delimited text file with "exportTSStable" function or bedGraph/BigWig files with "exportTSStoBedgraph" fucntion. bedGraph/BigWig files can be visualized in the UCSC Genome Browser or Integrative Genomics Viewer (IGV) or Genome Browser at YeasTSS.org for selected yeast species.
 
        exportTSStable(myTSSr, data = "processed") 
        exportTSStoBedgraph(myTSSr, data = "processed", format = "bedGraph") 
        exportTSStoBedgraph(myTSSr, data = "processed", format = "BigWig")
        
* Clustering TSSs to infer core promoters with “clusterTSS” function. 

  The “clusterTSS” function was designed to group neighboring TSSs into distinct TSS clusters (TCs), representing putative core promoters. It implements a TSS clustering algorithm based on peaking identification, namely “peakclu” (peak clustering) (Lu and Lin, 2021). Briefly, peakclu applies a sliding window approach (default window size = 100 bp with step size = 1) to scan TSS signals from the 5′ end of both strands of each chromosome. In each window, the TSS with the highest TPM value was identified as the peak. The surrounding TSSs are grouped with the peak into a TC. The clustering process of a TC terminates if a TSS is ≥ n bp (default n = 25) away from the nearest upstream TSS. In addition to setting a minimal allowed distance between peaks, TSSr offers another option to set maximal allowed extension distance between neighboring TSSs around peaks, which enables users to define the boundaries between neighboring core promoters. clusterTSS calculates inter-quantile width of a core promoter based on the cumulative distribution of TSS signals within the promoter. The positions of the 10th to 90th quantiles of TSS signals, which include at least 80% transcription initiation signals within a cluster, were defined as the 5’ and 3’ boundaries of the core promoter. The clustering step might be slow especially when the number of TSSs is in millions. Using multicores is highly recommended.

        clusterTSS(myTSSr, method = "peakclu",peakDistance=100,extensionDistance=30
	           ,localThreshold = 0.02,clusterThreshold = 1
	           ,useMultiCore=FALSE, numCores=NULL)
	           
        myTSSr@tagClusters
        
        # $control
        #       cluster   chr  start    end strand dominant_tss       tags tags.dominant_tss  q_0.1  q_0.9 interquantile_width
        #    1:       1  chrI   6530   6564      +         6548   9.312118          3.724847   6530   6562                  33
        #    2:       2  chrI   7166   7189      +         7169   1.241616          0.620808   7166   7189                  24
        #    3:       3  chrI   8084   8087      +         8084   1.241616          0.620808   8084   8087                   4
        #    4:       4  chrI   9325   9411      +         9327   4.966464          1.241616   9327   9391                  65
        #    5:       5  chrI   9442   9479      +         9442   3.414443          1.862423   9442   9468                  27
        #   ---                                                                                                               
        # 3300:    3300 chrII 804855 804975      -       804895 260.739280         71.703301 804868 804899                  32
        # 3301:    3301 chrII 807129 807179      -       807165  16.761812          6.518482 807161 807168                   8
        # 3302:    3302 chrII 808679 808723      -       808723   1.862424          0.931212 808679 808723                  45
        # 3303:    3303 chrII 809353 809377      -       809377   1.862424          1.552020 809353 809377                  25
        # 3304:    3304 chrII 809707 809748      -       809707   4.035251          2.172827 809707 809724                  18

        # $treat
        #      cluster   chr  start    end strand dominant_tss       tags tags.dominant_tss  q_0.1  q_0.9 interquantile_width
        #   1:       1  chrI   6521   6564      +         6559   5.067037          1.753975   6530   6559                  30
        #   2:       2  chrI   7096   7118      +         7100   1.948860          0.584658   7096   7114                  19
        #   3:       3  chrI   8061   8087      +         8061   1.948860          0.584658   8061   8087                  27
        #   4:       4  chrI   9327   9476      +         9359  11.498278          1.753975   9327   9452                 126
        #   5:       5  chrI  11259  11343      +        11329  59.245376         21.827244  11288  11329                  42
        #  ---                                                                                                               
        # 3244:    3244 chrII 804855 804952      -       804895 155.908888         54.568111 804872 804901                  30
        # 3245:    3245 chrII 807118 807179      -       807165  13.642026          5.456811 807153 807165                  13
        # 3246:    3246 chrII 808655 808691      -       808679   1.753974          0.779544 808655 808691                  37
        # 3247:    3247 chrII 809377 809389      -       809377   1.169316          0.779544 809377 809389                  13
        # 3248:    3248 chrII 809707 809710      -       809707   1.364203          0.974431 809707 809710                   4

    The results of TSS clustering can be exported to delimited text file with "exportClustersTable" function or bedGraph files with "exportClustersToBed" fucntion.
 
        exportClustersTable(myTSSr, data = "tagClusters")
        exportClustersToBed(myTSSr, data = "tagClusters") 
	
* Aggregating consensus TSS clusters

  TSSr infers a set of consensus core promoters using the “consensusCluster” function to assign the same ID for TCs belong to the same core promoter, which allows subsequent comparative studies across samples. TCs from different samples are considered to belong to the same consensus core promoter if the distance of their dominant TSSs is smaller than a user-defined distance (default = 50 bp). Similarly to clusterTSS function, consensusCluster function also returns genomic coordinates, sum of TSS tags, dominate TSS coordinate, a lower (q0.1) and an upper (q0.9) quantile coordinates, and interquantile widths for each consensus cluster in each sample.
  
        consensusCluster(myTSSr, dis = 50, useMultiCore = FALSE)
		    
  Similarly, the detailed information of consensus clusters can be exported to delimited text files with "exportClustersTable" function or bedGraph files with "exportClustersToBed" fucntion. 

        exportClustersTable(myTSSr, data = "consensusClusters")
        exportClustersToBed(myTSSr, data = "consensusClusters")	

* Quantification of core promoter shape

  Core promoter shape reflects the distribution of TSS signals within a core promoter. TSSr provides three different options, inter-quantile width, shape index (SI), and promoter shape score (PSS), to quantify core promoter shape. Inter-quantile width refers to the distance between the locations of the 10th percentile to the 90th percentile TSS signals within a TSS cluster.  Thus, it measures the width of a core promoter, but lacks the information of distribution patterns of TSS signals within a core promoter. Inter-quantile width could be significantly affected by different clustering methods. plotInterQuantile function plots interquantile width of each sample.

        plotInterQuantile(myTSSr,samples = "all",tagsThreshold = 1)
    
![03_Interquantile_plot_of_ALL_samples](https://github.com/Linlab-slu/TSSr/raw/master/vignettes/figures/03_Interquantile_plot_of_ALL_samples_v2.png)

  SI is determined by the probabilities of tags at every TSSs within one cluster (Hoskins, Landolin et al. 2011). SI is calculated using shapeCluster function with method set as “SI”. The greater value represents the sharper core promoter. SI is 2 representing singletons. Genome-wide SI score can be plotted with plotShape function.

  Promoter shape score (PSS) integrates both inter quantile width and the observed probabilities of tags at every TSSs within a cluster (Lu and Lin 2019). PSS can be calculated using using shapeCluster function with method set as “PSS”. The smaller value represents the sharper core promoter. PSS is 0 representing singletons. Genome-wide PSS score can be plotted with plotShape function.
  
        shapeCluster(myTSSr,clusters = "consensusClusters", method = "PSS",useMultiCore= FALSE, numCores = NULL)

        myTSSr@clusterShape
        
        # $control
        #       cluster   chr  start    end strand dominant_tss       tags tags.dominant_tss  q_0.1  q_0.9 interquantile_width shape.score
        #    1:       1  chrI   6530   6564      +         6548   9.312118          3.724847   6530   6562                  33    9.646916
        #    2:       3  chrI   7166   7189      +         7169   1.241616          0.620808   7166   7189                  24    6.877444
        #    3:       4  chrI   8084   8087      +         8084   1.241616          0.620808   8084   8087                   4    2.000000
        #    4:       5  chrI   9325   9411      +         9327   4.966464          1.241616   9327   9391                  65   17.767262
        #    5:       6  chrI   9442   9479      +         9442   3.414443          1.862423   9442   9468                  27    7.469695
        #   ---                                                                                                                           
        # 3299:    4286 chrII 804855 804975      -       804895 260.739280         71.703301 804868 804899                  32   14.764972
        # 3300:    4287 chrII 807129 807179      -       807165  16.761812          6.518482 807161 807168                   8    5.251317
        # 3301:    4288 chrII 808679 808723      -       808723   1.862424          0.931212 808679 808723                  45    9.844044
        # 3302:    4289 chrII 809353 809377      -       809377   1.862424          1.552020 809353 809377                  25    3.018611
        # 3303:    4290 chrII 809707 809748      -       809707   4.035251          2.172827 809707 809724                  18    7.425270
        # 
        # $treat
        #       cluster   chr  start    end strand dominant_tss       tags tags.dominant_tss  q_0.1  q_0.9 interquantile_width shape.score
        #    1:       1  chrI   6521   6564      +         6559   5.067037          1.753975   6530   6559                  30   13.123285
        #    2:       2  chrI   7096   7118      +         7100   1.948860          0.584658   7096   7114                  19    9.333375
        #    3:       4  chrI   8061   8087      +         8061   1.948860          0.584658   8061   8087                  27    9.012708
        #    4:       5  chrI   9327   9476      +         9359  11.498278          1.753975   9327   9452                 126   25.664108
        #    5:       7  chrI  11259  11343      +        11329  59.245376         21.827244  11288  11329                  42   15.020408
        #   ---                                                                                                                           
        # 3240:    4286 chrII 804855 804952      -       804895 155.908888         54.568111 804872 804901                  30   13.439327
        # 3241:    4287 chrII 807118 807179      -       807165  13.642026          5.456811 807153 807165                  13    7.308196
        # 3242:    4288 chrII 808655 808691      -       808679   1.753974          0.779544 808655 808691                  37   10.725295
        # 3243:    4289 chrII 809377 809389      -       809377   1.169316          0.779544 809377 809389                  13    3.398098
        # 3244:    4290 chrII 809707 809710      -       809707   1.364203          0.974431 809707 809710                   4    1.726241

        plotShape(myTSSr)
    
![04_Shape_plot_of_ALL_samples](https://github.com/Linlab-slu/TSSr/raw/master/vignettes/figures/04_Shape_plot_of_ALL_samples_v2.png)

   The complete list of PSS can be exported to delimited text file with "exportShapeTable" function. 

	exportShapeTable(myTSSr)

* Annotation (Assigning TCs to genes)

  Assigning TCs to downstream genes as their core promoters is required for annotation of the 5’ boundaries of genomic features. This process is also a prerequisite for further interrogations of regulated transcription initiation at the gene level. TSSr offers the “annotateCluster” function to assign TCs to their downstream genes. The assignment of a TC to a gene is based on the distance between the position of the dominant TSS of a TC and the annotated 5’ends of coding sequences (CDS) or transcripts. The default maximum distance between the dominant TSS and CDS is 1000 bp (“upstream = 1000”). If a TC overlaps with the CDS of an upstream gene, the dominant TSS of the TC must be within 500 bp to the 3’end of the overlapping CDS by default (“upstreamOverlap = 500”) to be eligible to assign to its downstream gene. If the 5’ends of annotated transcripts, instead of CDS, are used for TC assignment, users should set “annotationType” as “transcript,” and the default distance parameter is 500 bp. Because the genomes size and the number of introns vary substantially among organisms, it is necessary to apply customized criteria for TC assignment for different organisms. Users are advised to adjust the assignment criteria for core promoter assignment in TSSr. By default, only TCs with ≥ 0.02 TPM are used for the annotation process. To reduce transcriptional or technical noise of small clusters downstream a strong cluster, the filterCluster argument was set as "filterClusterThreshold = 0.02", indicating that any TC with TPM value < 0.02 TPM will be excluded from assigning to genes. 

        annotateCluster(myTSSr,clusters = "consensusClusters",filterCluster = TRUE,
	                filterClusterThreshold = 0.02, annotationType = "genes"
	                ,upstream=1000, upstreamOverlap = 500, downstream = 0)
	                
        myTSSr@assignedClusters
        
        # $control
        #      cluster   chr  start    end strand dominant_tss       tags tags.dominant_tss  q_0.1  q_0.9 interquantile_width      gene inCoding
        #   1:       5  chrI   9325   9411      +         9327   4.966464          1.241616   9327   9391                  65   YAL066W     <NA>
        #   2:       6  chrI   9442   9479      +         9442   3.414443          1.862423   9442   9468                  27   YAL066W     <NA>
        #   3:       7  chrI  11253  11343      +        11329  40.662913         17.693022  11275  11329                  55 YAL064W-B     <NA>
        #   4:      33  chrI  31026  31151      +        31108  48.112608         17.072215  31108  31145                  38   YAL062W     <NA>
        #   5:      34  chrI  31187  31263      +        31242 320.026426        122.609541  31212  31242                  31   YAL062W     <NA>
        #  ---                                                                                                                                  
        # 853:    4280 chrII 801003 801075      -       801023  11.174543          4.656059 801018 801061                  44 YBR296C-A     <NA>
        # 854:    4285 chrII 804563 804593      -       804592   1.552020          0.931212 804563 804593                  31   YBR298C     <NA>
        # 855:    4286 chrII 804855 804975      -       804895 260.739280         71.703301 804868 804899                  32   YBR298C     <NA>
        # 856:    4289 chrII 809353 809377      -       809377   1.862424          1.552020 809353 809377                  25   YBR300C     <NA>
        # 857:    4290 chrII 809707 809748      -       809707   4.035251          2.172827 809707 809724                  18   YBR300C     <NA>
        # 
        # $treat
        #      cluster   chr  start    end strand dominant_tss       tags tags.dominant_tss  q_0.1  q_0.9 interquantile_width      gene inCoding
        #   1:       5  chrI   9327   9476      +         9359  11.498278          1.753975   9327   9452                 126   YAL066W     <NA>
        #   2:       7  chrI  11259  11343      +        11329  59.245376         21.827244  11288  11329                  42 YAL064W-B     <NA>
        #   3:       8  chrI  11907  11934      +        11919   2.338633          0.974431  11916  11922                   7 YAL064W-B     <NA>
        #   4:      19  chrI  21237  21248      +        21246   1.948861          1.169317  21240  21246                   7   YAL064W     <NA>
        #   5:      34  chrI  31087  31263      +        31242 117.711208         34.299955  31119  31242                 124   YAL062W     <NA>
        #  ---                                                                                                                                  
        # 810:    4272 chrII 799105 799126      -       799126   1.169316          0.584658 799105 799126                  22   YBR296C     <NA>
        # 811:    4280 chrII 801017 801061      -       801023   6.821011          2.338633 801023 801058                  36 YBR296C-A     <NA>
        # 812:    4286 chrII 804855 804952      -       804895 155.908888         54.568111 804872 804901                  30   YBR298C     <NA>
        # 813:    4289 chrII 809377 809389      -       809377   1.169316          0.779544 809377 809389                  13   YBR300C     <NA>
        # 814:    4290 chrII 809707 809710      -       809707   1.364203          0.974431 809707 809710                   4   YBR300C     <NA>

  Instead of visualizing TSSs and core promoters in the UCSC Genome Browser or IGV, plotTSS function is able to generate publish ready figures when list of interested genes are provided and plotting region is specified.
                  
  The results of TC annotation can be exported to delimited text files with "exportClustersTable" function. 
        
        exportClustersTable(myTSSr, data = "assigned")

* Differential expression analysis

  The number of tags at each TSS reflects the number of transcripts initiated at the TSS. Thus, TSS data can be used for expression profiling. With specified sample pairs for comparison, deGene function counts raw tags of each consensus clusters and utilizes the DESeq2 package (Love, Huber et al. 2014) for differential expression analysis. 
        
        deGene(myTSSr,comparePairs=list(c("control","treat")), pval = 0.01,useMultiCore=FALSE, numCores=NULL)
        
  Differential expression analysis results can be visualized by plotDE function which generates a volcano plots. Names of genes differential expressed between the compared pairs are displayed on the dots when the withGeneName argument is set as TRUE.  

        plotDE(myTSSr, withGeneName = "TRUE",xlim=c(-2.5, 2.5),ylim=c(0,10))


  Differential expression analysis results can also be exported to a text file with exportDETable function. 

        exportDETable(myTSSr, data = "sig")

![05_Volcano_plot](https://github.com/Linlab-slu/TSSr/raw/master/vignettes/figures/05_Volcano_plot_v2.png)

* Core promoter shifts

  One gene might have multiple core promoters which can be used differently in different samples. TSSr implements degree of shift (Ds) algorithm (Lu and Lin 2019) to quantify the degree of promoter shift across different samples.

        shiftPromoter(myTSSr,comparePairs=list(c("control","treat")), pval = 0.01)
                
        myTSSr@PromoterShift
        
        # $control_VS_treat
        #          gene                Ds                  pval          padj
        #  1:   YBL017C  16.5567506300711                     0  0.000000e+00
        #  2:   YBR006W -26.3346456757359                     0  0.000000e+00
        #  3:   YBR023C  18.2077046044299                     0  0.000000e+00
        #  4:   YBR039W -27.6613679931366                     0  0.000000e+00
        #  5:   YBR121C -32.7186775913908                     0  0.000000e+00
        #  6:   YBL067C -25.5609100771941 4.82850134420976e-307 2.253301e-305
        #  7:   YBL052C  24.6257478761727 7.26364747717188e-223 2.542277e-221
        #  8:   YBL061C  23.9226054570548 4.67819852942603e-211 1.455440e-209
        #  9: YBR162W-A -3.11046343563838 8.57254730119706e-178 2.400313e-176
        # 10:   YBR161W  13.8279474932153 9.82622800918837e-106 2.292787e-104
        # 11:   YBL003C -4.19847808240255  5.1964924531945e-103 1.119245e-101
        # 12:   YBR225W  13.4149548647111  6.4269334028266e-103 1.285387e-101
        # 13:   YAL002W  11.0783513437554  9.36722953965125e-38  1.248964e-36
        # 14:   YBL002W  -4.1133471925947  1.79254923091534e-22  1.792549e-21
        # 15:   YBR203W  10.6629850364627  7.02368199407009e-21  6.781486e-20
        # 16:   YAL054C  -3.1805025752741  1.80946689382427e-16  1.688836e-15
        # 17:   YBR295W  9.67791801936358  2.28926136502023e-16  2.067720e-15
        # 18:   YBR296C  9.30290660727171  2.36023239071828e-14  2.065203e-13
        # 19:   YBR093C -3.40798742790801  2.00916389468933e-13  1.704745e-12
        # 20: YBR084C-A  9.11527727298199  2.57854085586531e-13  2.123504e-12
        # 21:   YBR184W -15.2971031957146  1.90180856743423e-12  1.521447e-11
        # 22:   YBR156C   -15.10487255485  3.10952877910847e-11  2.418522e-10
        # 23:   YBL045C  8.74743526840298  2.24860038205826e-10  1.649988e-09
        # 24:   YBR211C  8.83205164938185  2.29819756625836e-10  1.649988e-09
        # 25:   YBR175W -9.29322141796793  7.46451552866191e-10  5.225161e-09
        # 26:   YBR260C  8.59396786414482   6.1189233992215e-09  4.178777e-08
        # 27:   YBR015C -1.55009599585459   2.5144638411962e-08  1.676309e-07
        # 28:   YBR218C  8.34981937289533  5.06126915693087e-08  3.287460e-07
        # 29:   YBR244W  8.30806489068964  5.16600880899288e-08  3.287460e-07
        # 30:   YBL054W   2.8341173250082  8.07918244515885e-08  5.027047e-07
        # 31: YAL026C-A -9.04035405768231  1.68525949110593e-07  1.003984e-06
        # 32:    snR161 -2.50921709668593  4.57553973228071e-07  2.669065e-06
        # 33:  tQ(UUG)B   8.4166183829428  2.80004547044555e-06  1.600026e-05
        # 34:   YBL040C  7.85978512550703  5.67754708991627e-06  3.179426e-05
        # 35:   YBR117C -2.07135794086609  2.15793728644816e-05  1.184750e-04
        # 36:   YBL103C  7.60938746583251  3.47531850741136e-05  1.845650e-04
        # 37:   YBR270C  -1.7014289300971   3.4935512199854e-05  1.845650e-04
        # 38:   YBR008C  1.03566759072034  3.91024884830601e-05  2.027536e-04
        # 39:   YBL026W  7.50615085133225  5.64749784425959e-05  2.875090e-04
        # 40:   YBL022C 0.792377149588471  7.40429250345774e-05  3.702146e-04
        # 41:   YAL062W  7.47110168494036   7.6562991161926e-05  3.760989e-04
        # 42:   YAL018C -2.96325319131017                     1  1.000000e+00
        # 43:   YBL083C 0.373945070392578                     1  1.000000e+00
        # 44: YBR012W-A -2.82952533010526                     1  1.000000e+00
        # 45:   YBR300C 0.869273808837717                     1  1.000000e+00
        #          gene                Ds                  pval          padj


  Below is an example of core promoter shift in gene YBL017C. The two major core promoters are differently used in control and treat samples.

        plotTSS(myTSSr,samples=c("control","treat"),tssData = "processed"
        ,clusters = "assigned"
        ,clusterThreshold = 0.02 
        ,genelist=c("YBR168W","YBL067C")
        ,up.dis =500,down.dis = 100,yFixed=TRUE)
          
![06_TSS_graphs](https://github.com/Linlab-slu/TSSr/raw/master/vignettes/figures/06_TSS_graphs_v2.png)

  Results of core promoter shift analysis can also be exported to a text file with exportShiftTable function.
        
        exportShiftTable(myTSSr)
    

## 7. Contact:

Zhenguo Lin, PhD

Department of Biology, Saint Louis University, USA.

Email: zhenguo.lin@slu.edu

## 8. Reference:

Arribere, J. A. and W. V. Gilbert (2013). "Roles for transcript leaders in translation and mRNA decay revealed by transcript leader sequencing." Genome Res 23(6): 977-987.

Cumbie, J. S., M. G. Ivanchenko and M. Megraw (2015). "NanoCAGE-XL and CapFilter: an approach to genome wide identification of high confidence transcription start sites." BMC Genomics 16: 597.

Cvetesic, N., H. G. Leitch, M. Borkowska, F. Muller, P. Carninci, P. Hajkova and B. Lenhard (2018). "SLIC-CAGE: high-resolution transcription start site mapping using nanogram-levels of total RNA." Genome Res 28(12): 1943-1956.

Kruesi, W. S., L. J. Core, C. T. Waters, J. T. Lis and B. J. Meyer (2013). "Condensin controls recruitment of RNA polymerase II to achieve nematode X-chromosome dosage compensation." Elife 2: e00808.

Mahat, D. B., H. Kwak, G. T. Booth, I. H. Jonkers, C. G. Danko, R. K. Patel, C. T. Waters, K. Munson, L. J. Core and J. T. Lis (2016). "Base-pair-resolution genome-wide mapping of active RNA polymerases using precision nuclear run-on (PRO-seq)." Nat Protoc 11(8): 1455-1476.

Mahat, D. B., H. Kwak, G. T. Booth, I. H. Jonkers, C. G. Danko, R. K. Patel, C. T. Waters, K. Munson, L. J. Core and J. T. Lis (2016). "Base-pair-resolution genome-wide mapping of active RNA polymerases using precision nuclear run-on (PRO-seq)." Nat Protoc 11(8): 1455-1476.

Malabat, C., F. Feuerbach, L. Ma, C. Saveanu and A. Jacquier (2015). "Quality control of transcription start site selection by nonsense-mediated-mRNA decay." Elife 4.

Murata, M., H. Nishiyori-Sueki, M. Kojima-Ishiyama, P. Carninci, Y. Hayashizaki and M. Itoh (2014). "Detecting expressed genes using CAGE." Methods Mol Biol 1164: 67-85.

Pelechano, V., W. Wei and L. M. Steinmetz (2013). "Extensive transcriptional heterogeneity revealed by isoform profiling." Nature 497(7447): 127-131.

Takahashi, H., T. Lassmann, M. Murata and P. Carninci (2012). "5' end-centered expression profiling using cap-analysis gene expression and next-generation sequencing." Nat Protoc 7(3): 542-561.

