##run script with the following example command:
##.assign2gene(clusters,reference,organim,upstream=1000, upstreamOverlap = 500)
.assign2gene <- function(clusters,ref,upstream, upstreamOverlap, downstream){
ref[, "subset" := paste0(seqnames,"_",strand)]
setkey(ref,subset)
clusters[, "subset" := paste0(chr,"_",strand)]
setkey(clusters,subset)
asn <- lapply(as.list(clusters[,unique(subset)]), function(x) {
cs <- clusters[.(x)]
cs[,subset:= NULL]
colnames(cs)[3:4] <- c("start.c","end.c")
gr <- makeGRangesFromDataFrame(cs, keep.extra.columns= T, start.field = "dominant_tss", end.field = "dominant_tss")
ref_sub <- subset(ref[ref$subset == x,]) ## why ref_sub <- ref[.(x)] not working when x == "chrM_-"?
if(nrow(ref_sub) == 0){
mcols(gr)[,"gene"] <- NA
}else{
if(cs$strand[1] == "+"){
setorder(ref_sub,start)
ref_sub[,end.b:=data.table::shift(end, 1, fill = 0,type='lag')]
ref_sub[,width:=data.table::shift(width, 1, fill = 1000,type='lag')]
ref_sub[,dis := start - end.b]
ref_sub[,dis:= ifelse(dis < 0, 0,dis)]
ref_sub[,up:= ifelse(dis > upstream, upstream,
ifelse(dis + width  <= upstreamOverlap, dis + width -1,
ifelse(dis < upstreamOverlap, upstreamOverlap, dis)))]
ref_sub[,end:= start + downstream] ##start - 1 -> start April10
ref_sub[,start := end - downstream - up +1]
}else{
setorder(ref_sub,end)
ref_sub[,end.b:=data.table::shift(start, 1, fill = 0,type='lead')]
ref_sub[(.N),end.b := end + 1000]
ref_sub[,width:=data.table::shift(width, 1, fill = 1000,type='lead')]
ref_sub[,dis := end.b - end] ##start -> end April10
ref_sub[,dis:= ifelse(dis < 0,0,dis)]
ref_sub[,up:= ifelse(dis > upstream, upstream,
ifelse(dis + width  <= upstreamOverlap, dis + width -1,
ifelse(dis < upstreamOverlap, upstreamOverlap, dis)))]
ref_sub[,start:= end- downstream]##end + 1 -> end April10
ref_sub[,end:= start + downstream + up -1]
}
rownames(ref_sub) <- ref_sub$gene_id
ref_sub <- makeGRangesFromDataFrame(ref_sub, keep.extra.columns= F)
hits <- findOverlaps(gr,ref_sub)
hits <- breakTies(hits, method = "first")
hits <- methods::as(hits, "List")
hits <- extractList(names(ref_sub), hits)
hits <- as.character(hits)
mcols(gr)[,"gene"] <- hits
}
gr <- as.data.frame(gr)
gr$dominant_tss <- gr$start
colnames(gr)[c(1,7,8)] <- c("chr","start","end")
gr <- gr[,c(6,1,7,8,5,15,9:14)]
return(gr)
})
setorder(do.call("rbind",asn), cluster)
}
#####################################################################################################
################################################################################################
setGeneric("annotateCluster",function(object,...)standardGeneric("annotateCluster"))
setMethod("annotateCluster","TSSr", function(object
,clusters = "tagClusters"
,reference
,organim
,annotationType = "genes"
,upstream=1000
,upstreamOverlap = 500
,downstream = 0
){
message("\nAnnotating...")
Genome <- .getGenome(object@genomeName)
sampleLabelsMerged <- object@sampleLabelsMerged
objName <- deparse(substitute(myTSSr))
refGFF <- object@refSource
organismName <- object@organismName
##prepare annotation file
txdb <- suppressWarnings(makeTxDbFromGFF(refGFF, organismName, format = "auto"))
if(annotationType == "genes"){
ref <- setDT(as.data.frame(genes(txdb)))
}else if(annotationType == "transcripts"){
ref <- setDT(as.data.frame(transcripts(txdb)))
}
##prepare clusters
if(clusters == "tagClusters"){
cs.dt <- object@tagClusters
}else if(clusters == "consensusClusters"){
cs.dt <- object@consensusClusters
}
##
asn <- lapply(as.list(seq(sampleLabelsMerged)), function(i){
cs <- cs.dt[[sampleLabelsMerged[i]]]
cs.asn <- .assign2gene(cs,ref,upstream, upstreamOverlap, downstream)
return(cs.asn)
})
names(asn) <- sampleLabelsMerged
##subset assigned
asned <- lapply(as.list(seq(sampleLabelsMerged)), function(i){
cs <- asn[[sampleLabelsMerged[i]]]
cs <- cs[!is.na(cs$gene),]
setDT(cs)
return(cs)
})
##subset unassigned
unasn <- lapply(as.list(seq(sampleLabelsMerged)), function(i){
cs <- asn[[sampleLabelsMerged[i]]]
cs <- cs[is.na(cs$gene),]
setDT(cs)
return(cs)
})
cat("\n")
names(asned) <- sampleLabelsMerged
names(unasn) <- sampleLabelsMerged
object@assignedClusters <- asned
object@unassignedClusters <- unasn
assign(objName, object, envir = parent.frame())
})
myTSSr <- getTSS(myTSSr)
################################################################################################
##
################################################################################################
setGeneric("clusterTSS",function(object,...)standardGeneric("clusterTSS"))
setMethod("clusterTSS","TSSr", function(object,data = "raw", method = "peakclu"
,peakDistance=100, localThreshold = 0.02
,extensionDistance=30,clusterThreshold = 1
, nonOverLapping=TRUE
,useMultiCore=FALSE, numCores=NULL
){
message("\nClustering TSS data with ", method, " method...")
##initialize values
Genome <- .getGenome(object@genomeName)
sampleLabelsMerged <- object@sampleLabelsMerged
objName <- deparse(substitute(myTSSr))
##pick which data will be used for clustering
if(data == "raw"){
tss.dt <- object@TSSrawMatrix
}else if(data == "filtered"){
tss.dt <- object@TSSfilteredMatrix
}
# pass sub datatables to peak-caller and clustering functions
if (useMultiCore) {
library(parallel)
if (is.null(numCores)) {
numCores <- detectCores()
}
print(paste("process is running on", numCores, "cores..."))
##separate tss table by sampleLables
cs <- lapply(as.list(seq(sampleLabelsMerged)), function(i){
temp <- tss.dt[,.SD, .SDcols = c("chr","pos","strand",sampleLabelsMerged[i])]
setnames(temp, colnames(temp)[[4]], "tags")
temp <- temp[tags >0,]
temp[, "subset" := paste0(chr,"_",strand)]
setkey(temp,subset)
clusters <- mclapply(as.list(temp[,unique(subset)]), function(x) {
tss <- temp[.(x)]
setkey(tss, NULL)
setorder(tss, pos)
if(method == "peakclu"){
cluster.data <- .clusterByPeak(tss, peakDistance, localThreshold, extensionDistance, nonOverLapping)
}
}, mc.cores = numCores)
tss.clusters <- rbindlist(clusters, use.names=TRUE, fill=TRUE)
tss.clusters <- tss.clusters[tags >clusterThreshold,]
setorder(tss.clusters, "strand","chr","start")
tss.clusters[, cluster := .I]
return(tss.clusters)
})
}else{
cs <- lapply(as.list(seq(sampleLabelsMerged)), function(i){
temp <- tss.dt[,.SD, .SDcols = c("chr","pos","strand",sampleLabelsMerged[i])]
setnames(temp, colnames(temp)[[4]], "tags")
temp <- temp[tags >0,]
temp[, "subset" := paste0(chr,"_",strand)]
setkey(temp,subset)
clusters <- lapply(as.list(temp[,unique(subset)]), function(x) {
tss <- temp[.(x)]
setkey(tss, NULL)
setorder(tss, pos)
if(method == "peakclu"){
cluster.data <- .clusterByPeak(tss, peakDistance, localThreshold, extensionDistance, nonOverLapping)
}
})
tss.clusters <- rbindlist(clusters, use.names=TRUE, fill=TRUE)
tss.clusters <- tss.clusters[tags >clusterThreshold,]
setorder(tss.clusters, "strand","chr","start")
tss.clusters[, cluster := .I]
tss.clusters <- tss.clusters[,-ncol(tss.clusters)]
return(tss.clusters)
})
}
cat("\n")
names(cs) <- sampleLabelsMerged
object@tagClusters <- cs
assign(objName, object, envir = parent.frame())
})
################################################################################################
setGeneric("plotCorrelation",function(object,...)standardGeneric("plotCorrelation"))
setMethod("plotCorrelation","TSSr", function(object
,samples = "all"
){
message("Plotting TSS correlations...")
tss.raw <- object@TSSrawMatrix
if(samples == "all"){
tss <- tss.raw
}else{
cols <- c("chr","pos","strand", samples)
tss <- tss.raw[,.SD, .SDcols = cols]
}
pdf(file = paste("TSS_correlation_plot_of_", paste(samples, collapse = "_"), "_samples.pdf", sep = "")
,width = 8, height = 8, onefile = T, bg = "transparent", family = "Helvetica", fonts = NULL)
.plotCorrelation(tss)
dev.off()
})
################################################################################################
setGeneric("plotInterQuantile",function(object,...)standardGeneric("plotInterQuantile"))
setMethod("plotInterQuantile","TSSr", function(object
,samples = "all"
,tagsThreshold = 1
){
message("Plotting interquantile graphs...")
TCs <- object@clusterShape
sampleLabels <- object@sampleLabelsMerged
if(samples == "all"){
tc <- TCs
pdf(file = paste("Interquantile_plot_of_ALL_samples.pdf", sep = "")
,width = 8, height = 8, onefile = T, bg = "transparent", family = "Helvetica", fonts = NULL)
for(i in 1:length(sampleLabels)){
temp <- tc[[sampleLabels[i]]]
temp <- temp[tags >= tagsThreshold & interquantile_width <= 200,]
hist(temp$interquantile_width, breaks = 40, col = rainbow(length(sampleLabels))[i]
, xlab = "TC interquantile width q0.1-q0.9", ylab = "Frequency", main = sampleLabels[i])
}
}else{
tc <- TCs[[samples]]
pdf(file = paste("Interquantile_plot_of_", paste(samples, collapse = "_"), "_samples.pdf", sep = "")
,width = 8, height = 8, onefile = T, bg = "transparent", family = "Helvetica", fonts = NULL)
for(i in 1:length(samples)){
temp <- tc[[samples[i]]]
temp <- temp[tags >= tagsThreshold & interquantile_width <= 200,]
hist(temp$interquantile_width, breaks = 40, col = rainbow(length(samples))[i]
, xlab = "TC interquantile width q0.1-q0.9", ylab = "Frequency", main = samples[i])
}
}
dev.off()
})
################################################################################################
setGeneric("plotShape",function(object,...)standardGeneric("plotShape"))
setMethod("plotShape","TSSr", function(object
,samples = "all"
){
message("Plotting Shape graphs...")
TCs <- object@clusterShape
sampleLabels <- object@sampleLabelsMerged
if(samples == "all"){
tc <- TCs
pdf(file = paste("Shape_plot_of_ALL_samples.pdf", sep = "")
,width = 8, height = 8, onefile = T, bg = "transparent", family = "Helvetica", fonts = NULL)
for(i in 1:length(sampleLabels)){
temp <- tc[[sampleLabels[i]]]
hist(temp$shape.score, breaks = 40, col = rainbow(length(sampleLabels))[i]
, xlab = "shape score", ylab = "Frequency", main = sampleLabels[i])
}
}else{
tc <- TCs[[samples]]
pdf(file = paste("Shape_plot_of_", paste(samples, collapse = "_"), "_samples.pdf", sep = "")
,width = 8, height = 8, onefile = T, bg = "transparent", family = "Helvetica", fonts = NULL)
for(i in 1:length(samples)){
temp <- tc[[samples[i]]]
hist(temp$shape.score, breaks = 40, col = rainbow(length(samples))[i]
, xlab = "shape score", ylab = "Frequency", main = samples[i])
}
}
dev.off()
})
################################################################################################
setGeneric("plotDE",function(object,...)standardGeneric("plotDE"))
setMethod("plotDE","TSSr", function(object
,withGeneName = "TRUE"
,xlim=c(-2.5, 2.5)
,ylim=c()
){
message("Plotting DE graphs...")
res <- object@DEtables$DEtable
pdf(file = paste("Volcano_plot.pdf", sep = ""),width = 8, height = 8,bg = "transparent"
, family = "Helvetica", fonts = NULL)
##
if(is.null(xlim)){
with(res, plot(log2FoldChange, -log10(pvalue), pch=20, main="Volcano plot"))
}else{
with(res, plot(log2FoldChange, -log10(pvalue), pch=20, main="Volcano plot", xlim=xlim,ylim = ylim))
}
# Add colored points: red if padj<0.05, orange of log2FC>1, green if both)
with(subset(res, padj<.05 ), points(log2FoldChange, -log10(pvalue), pch=20, col="red"))
with(subset(res, abs(log2FoldChange)>1), points(log2FoldChange, -log10(pvalue), pch=20, col="orange"))
with(subset(res, padj<.05 & abs(log2FoldChange)>1), points(log2FoldChange, -log10(pvalue), pch=20, col="green"))
if(withGeneName == "TRUE"){
with(subset(res, padj<.05 & abs(log2FoldChange)>1), textxy(log2FoldChange, -log10(pvalue), labs=gene, cex=.8))
}
dev.off()
})
################################################################################################
setGeneric("plotTSS",function(object,...)standardGeneric("plotTSS"))
setMethod("plotTSS","TSSr", function(object
,samples
,genelist
,up.dis =500
,down.dis = 500
){
message("Plotting TSS graphs...")
##initialize data
tss.filtered <- object@TSSfilteredMatrix
clusters <- object@tagClusters[[1]]
tss.raw <- object@TSSfilteredMatrix
refGFF <- object@refSource
organismName <- object@organismName
##prepare tss table
if(FALSE %in% unique(samples %in% sampleLabels)){
stop("No data for one or more given samples! ")
}else{
cols <- c("chr","pos","strand", samples)
tss <- tss.filtered[,.SD, .SDcols = cols]
}
tss.p <- tss[tss$strand == "+",]
tss.m <- tss[tss$strand == "-",]
tss.m[,(samples) := lapply(.SD, "*",-1), .SDcols = samples]
tss <- rbind(tss.p,tss.m)
##prepare annotation file
txdb <- suppressWarnings(makeTxDbFromGFF(refGFF, organismName, format = "auto"))
ref <- setDT(as.data.frame(genes(txdb)))
ref <- ref[gene_id %in% genelist,]
pdf(file = paste("TSS_graphs.pdf", sep = "")
,width = 10, height = 8, onefile = T, bg = "transparent", family = "Helvetica", fonts = NULL)
for (i in 1:nrow(ref)){
df <- ref[i,]
.plotTSS(tss, clusters,df, samples, up.dis, down.dis)
}
dev.off()
})
################################################################################################
setGeneric("exportTSStable",function(object,...)standardGeneric("exportTSStable"))
setMethod("exportTSStable","TSSr", function(object
,data = "raw"
,merged = "TRUE"
){
message("Exporting TSS table...")
if(data == "raw"){
if(merged == "TRUE"){
tss <- object@TSSmergedMatrix
write.table(tss, file = "TSS_table_ALL_samples_merged.txt", sep = "\t", quote = F, row.nams = F)
}else{
tss <- object@TSSrawMatrix
write.table(tss, file = "TSS_table_ALL_samples_unmerged.txt", sep = "\t", quote = F, row.nams = F)
}
}else if(data == "filtered"){
tss <- object@TSSfilteredMatrix
write.table(tss, file = "TSS_table_ALL_samples_filtered.txt", sep = "\t", quote = F, row.nams = F)
}else{
stop("No data for the given TSS data type!")
}
})
################################################################################################
setGeneric("exportTagClustersTable",function(object,...)standardGeneric("exportTagClustersTable"))
setMethod("exportTagClustersTable","TSSr", function(object
,data = "assigned"
){
message("Exporting tagClusters table...")
if(data == "assigned"){
tc <- object@assignedClusters
samples <- object@sampleLabelsMerged
for(i in 1:length(samples)){
temp <- tc[[samples[i]]]
write.table(temp, file = paste("TagClusters_assigned_",samples[i],".txt", sep = ""), sep = "\t", quote = F, row.nams = F)
}
}else if(data == "unassigned"){
tc <- object@unassignedClusters
samples <- object@sampleLabelsMerged
for(i in 1:length(samples)){
temp <- tc[[samples[i]]]
write.table(temp, file = paste("TagClusters_unassigned_",samples[i],".txt", sep = ""), sep = "\t", quote = F, row.nams = F)
}
}else{
stop("No data for the given tag cluster data type!")
}
})
################################################################################################
setGeneric("exportShapeTable",function(object,...)standardGeneric("exportShapeTable"))
setMethod("exportShapeTable","TSSr", function(object
){
message("Exporting promoter shape table...")
s <- object@clusterShape
if(!is.null(s)){
samples <- object@sampleLabelsMerged
for(i in 1:length(samples)){
temp <- s[[samples[i]]]
write.table(temp, file = paste("Peomoter_shape_",samples[i],".txt", sep = ""), sep = "\t", quote = F, row.nams = F)
}
}else{
stop("No data for the promoter shape!")
}
})
################################################################################################
setGeneric("exportDETable",function(object,...)standardGeneric("exportDETable"))
setMethod("exportDETable","TSSr", function(object
,data = "all"
){
message("Exporting differential expression table...")
if(data == "all"){
temp <- object@DEtables$DEtable
write.table(temp, file = paste("DE_table_ALL.txt", sep = ""), sep = "\t", quote = F, row.nams = F)
}else if(data == "sig"){
temp <- object@DEtables$DEsig
write.table(temp, file = paste("DE_table_sig.txt", sep = ""), sep = "\t", quote = F, row.nams = F)
}else{
stop("No data for the differential expression!")
}
})
################################################################################################
###################################################################################################################
##.deseq2 function calcuates gene differential expression based on Deseq2 package
##.deseq2 function takes two assigned clusters and tss.raw table
##users need to provide which sample they want to compare and
##run script with the following example command:
##.deseq2(clustersx.asn,clustersy.asn, tss.raw,
##                              samplex <- c("ScerBY4741.1","ScerBY4741.2"),
##                              sampley <- c("ScerArrest.1","ScerArrest.2"),
##                              sampleOne <- "ScerBY4741",sampleTwo <- "ScerArrest")
############################################################################
##tss.raw is the raw tss merged tables, before any sums
.deseq2 <- function(cx,cy, tss.raw, samplex,sampley, sampleOne,sampleTwo){
##get raw count tables
xCounts <-.tagCount(cx, tss.raw,samplex)
yCounts <-.tagCount(cy, tss.raw,sampley)
xCounts <- xCounts[,-c(2:11)]
yCounts <- yCounts[,-c(2:11)]
##tag counts by gene for sampleOne
setkey(xCounts, gene)
one <- lapply(as.list(unique(xCounts$gene)), function(my.gene) {
data <- xCounts[.(my.gene)]
return(c(my.gene,colSums(data[,-c(1,2)])))
})
one <- data.frame(matrix(unlist(one), nrow=length(one), byrow=T),stringsAsFactors=FALSE)
##tag counts by gene for sampleTwo
setkey(yCounts, gene)
two <- lapply(as.list(unique(yCounts$gene)), function(my.gene) {
data <- yCounts[.(my.gene)]
return(c(my.gene,colSums(data[,-c(1,2)])))
})
two <- data.frame(matrix(unlist(two), nrow=length(two), byrow=T),stringsAsFactors=FALSE)
##merge the two raw count tables together by genes
one[,2:3] <- sapply(one[,2:3], as.integer)
two[,2:3] <- sapply(two[,2:3], as.integer)
setnames(one, colnames(one), c("gene",samplex))
setnames(two, colnames(two), c("gene",sampley))
Dtable <- merge(one, two, by = c("gene"), all = T)
Dtable[is.na(Dtable)] = 0
##
rownames(Dtable) <- Dtable[,1]
Dtable <- Dtable[,-1]
Dtable <- data.matrix(Dtable)
condition <- factor(c(rep(sampleOne, times = length(samplex)), rep(sampleTwo, times = length(sampley))))
dds <- DESeqDataSetFromMatrix(countData = Dtable,DataFrame(condition), ~ condition)
dds <- DESeq(dds)
res <- results(dds)
res <- res[order(res$padj),]
return(as.data.frame(res))
}
############################################################################
##.tagCount is slow
.tagCount <- function(cs, tss.raw, samples){
cols <- c("chr","pos","strand", samples)
tss <- tss.raw[,.SD, .SDcols = cols]
tags <- lapply(seq_len(cs[,.N]),function(r){
data <- tss[tss$chr == cs[r,chr] & tss$strand == cs[r,strand] & tss$pos >= cs[r,start] & tss$pos <= cs[r,end],]
temp <- sapply(as.list(samples), function(s){
sum(data[,.SD,.SDcols = s])
})
return(temp)
})
tags <- data.frame(matrix(unlist(tags), nrow=length(tags), byrow=T),stringsAsFactors=FALSE)
colnames(tags) <- samples
cs <- cbind(cs,tags)
return(cs)
}
################################################################################################
setGeneric("deGene",function(object,...)standardGeneric("deGene"))
setMethod("deGene","TSSr", function(object
,sampleOne
,sampleTwo
,pval=0.01
){
##initialize data
objName <- deparse(substitute(myTSSr))
sampleLabels <- object@sampleLabels
sampleLabelsMerged <- object@sampleLabelsMerged
cx <- object@assignedClusters[[sampleOne]]
cy <- object@assignedClusters[[sampleTwo]]
tss.raw <- object@TSSrawMatrix
mergeIndex <- object@mergeIndex
samplex <- sampleLabels[which(mergeIndex ==which(sampleLabelsMerged == sampleOne))]
sampley <- sampleLabels[which(mergeIndex ==which(sampleLabelsMerged == sampleTwo))]
DE.dt <- .deseq2(cx,cy,tss.raw,samplex, sampley, sampleOne, sampleTwo)
DE.sig <- subset(DE.dt, padj < pval)
DE.dt$gene <- row.names(DE.dt)
DE.sig$gene <- row.names(DE.sig)
DE.dt <- DE.dt[,c(ncol(DE.dt), 1:(ncol(DE.dt)-1))]
DE.sig <- DE.sig[,c(ncol(DE.sig), 1:(ncol(DE.sig)-1))]
setDT(DE.dt)
setDT(DE.sig)
DE <- list("DEtable" = DE.dt, "DEsig" = DE.sig)
cat("\n")
object@DEtables <- DE
assign(objName, object, envir = parent.frame())
})
